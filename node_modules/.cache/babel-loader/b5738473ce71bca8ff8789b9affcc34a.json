{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { createAction, handleActions } from \"redux-actions\";\nimport { useSelector } from \"react-redux\";\nimport { createSelector } from \"reselect\";\nimport { updateMonster } from './monster';\nimport { updatePlayer, discardHand, drawCard, addCardDiscard, addAilgments, playCard } from './player';\nimport { afflictionCards } from '../game-data/affliction-card-data';\nexport const updateCombat = createAction('combat/UPDATE_COMBAT');\nexport const logCombat = createAction('combat/LOG_COMBAT');\nexport const resetCombatLog = createAction('combat/RESET_COMBAT_LOG');\nconst initialState = {\n  combatLog: [{\n    origin: 'player',\n    description: 'Start of combat'\n  }]\n};\nexport default handleActions({\n  [updateCombat]: (state, action) => ({ ...state,\n    ...action.payload\n  }),\n  [logCombat]: (state, action) => ({ ...state.combatLog,\n    combatLog: [...state.combatLog, action.payload]\n  })\n}, initialState); // how we grab data from the store\n\nconst selectCombat = createSelector(state => state.combat, combat => combat);\nexport const useCombat = () => {\n  _s();\n\n  return useSelector(selectCombat);\n};\n\n_s(useCombat, \"nKHvd/QB6hocKEk0fSJoSYcCyR8=\", false, function () {\n  return [useSelector];\n});\n\nfunction strikeAnimation(bodyElement) {\n  let transitionTime = 500;\n  bodyElement.animate([{\n    transform: 'translate(0px,0px)'\n  }, {\n    transform: 'translate(-50px, 0px)'\n  }, {\n    transform: 'translate(-105px, 0px)'\n  }, {\n    transform: 'translate(1px, 0px)'\n  }, {\n    transform: 'translate(0, 0px)'\n  }], {\n    duration: transitionTime,\n    iterations: 1\n  });\n}\n\nfunction hitHero() {\n  let roll = getRandomRange(0, 3);\n\n  switch (roll) {\n    case 0:\n      damageFlash(document.getElementById('mageBody'));\n      break;\n\n    case 1:\n      damageFlash(document.getElementById('swordBody'));\n      break;\n\n    case 2:\n      damageFlash(document.getElementById('shieldBody'));\n      break;\n  }\n}\n\nfunction damageFlash(bodyElement) {\n  let transitionTime = 500;\n  bodyElement.animate([{\n    opacity: 1\n  }, {\n    opacity: 0\n  }, {\n    opacity: .75\n  }, {\n    opacity: .5\n  }, {\n    opacity: 0\n  }, {\n    opacity: .75\n  }, {\n    opacity: 1\n  }], {\n    duration: transitionTime,\n    iterations: 1\n  });\n}\n\nfunction reduceAligments(player) {\n  for (let index = 0; index < player.offenseHeroAilgments.length; index++) {\n    if (parseInt(player.offenseHeroAilgmentsDuration[index]) - 1 > 0) {\n      // last turn with given ailgment.\n      player.offenseHeroAilgmentsDuration[index] -= 1;\n    } else {\n      // aligment is removed.\n      player.offenseHeroAilgments.splice(index, 1);\n      player.offenseHeroAilgmentsDuration.splice(index, 1);\n    }\n  }\n\n  for (let index = 0; index < player.utilityHeroAilgments.length; index++) {\n    if (parseInt(player.utilityHeroAilgmentsDuration[index]) - 1 > 0) {\n      // last turn with given ailgment.\n      player.utilityHeroAilgmentsDuration[index] -= 1;\n    } else {\n      // aligment is removed.\n      player.utilityHeroAilgments.splice(index, 1);\n      player.utilityHeroAilgmentsDuration.splice(index, 1);\n    }\n  }\n\n  for (let index = 0; index < player.defenseHeroAilgments.length; index++) {\n    if (parseInt(player.defenseHeroAilgmentsDuration[index]) - 1 > 0) {\n      // last turn with given ailgment.\n      player.defenseHeroAilgmentsDuration[index] -= 1;\n    } else {\n      // aligment is removed.\n      player.defenseHeroAilgments.splice(index, 1);\n      player.defenseHeroAilgmentsDuration.splice(index, 1);\n    }\n  }\n}\n\nfunction reduceMonsterAligments(monster) {\n  for (let index = 0; index < monster.aligment.length; index++) {\n    if (parseInt(monster.aligmentDuration[index]) - 1 === 1) {\n      // last turn with given ailgment. Maybe...\n      monster.aligmentDuration[index] -= 1;\n    } else if (parseInt(monster.aligmentDuration[index]) - 1 <= 0) {\n      // aligment is removed.\n      monster.aligmentDuration.splice(index, 1);\n      monster.aligment.splice(index, 1);\n    }\n  }\n}\n\nfunction getRandomRange(min, max) {\n  return Math.floor(Math.random() * (max - min) + min);\n}\n\nexport const endTurn = () => (dispatch, getState) => {\n  let playerOverlay = document.getElementById('playerOverlay');\n  playerOverlay.style.height = \"50vh\";\n  playerOverlay.style.width = \"100vw\";\n  playerOverlay.style.transform = \"translate(0px,50px)\";\n  playerOverlay.style.backgroundColor = \"black\";\n  playerOverlay.style.opacity = .75;\n  playerOverlay.style.position = \"absolute\";\n  playerOverlay.style.zIndex = 100;\n  playerOverlay.style.bottom = 0;\n  let monsterBody = document.getElementById('monsterOuterContainer');\n  setTimeout(function () {\n    dispatch(discardHand());\n  }, 1000);\n  const state = getState();\n  const player = state.player;\n  const monster = state.monster;\n  monster.defense = 0;\n  const telegraphing = monster.telegraphing;\n  console.log('telegraph:', telegraphing);\n\n  if (!monster.aligment.includes('stun')) {\n    for (let m = 0; m < telegraphing.effect.length; m++) {\n      if (telegraphing.effect[m] == \"damage\") {\n        strikeAnimation(monsterBody);\n        hitHero();\n        const dmg = telegraphing.power[m];\n        const moveMsg = monster.name + \" used \" + telegraphing.name[m] + \", dealing\\n\" + telegraphing.power[m] + \" damage.\";\n        setTimeout(function () {\n          dispatch(logCombat({\n            origin: 'monster',\n            description: moveMsg\n          }), 1000);\n        }, 1000);\n        const trample = player.defense - dmg;\n\n        if (trample <= 0) {\n          const newDefense = 0;\n          const newHealth = player.health + trample;\n          setTimeout(function () {\n            dispatch(updatePlayer({\n              health: newHealth,\n              defense: newDefense\n            }));\n          }, 1000);\n        } else {\n          const newDefense = trample;\n          setTimeout(function () {\n            dispatch(updatePlayer({\n              defense: newDefense\n            }));\n          }, 1000);\n        }\n      } else if (telegraphing.effect[m] == 'defense') {\n        const newDefense = telegraphing.power[m];\n        const moveMsg = monster.name + \" used \" + telegraphing.name[m] + \", gained\\n +\" + telegraphing.power[m] + \" defense.\";\n        setTimeout(function () {\n          //  combatMsgs.innerHTML = moveMsg \n          dispatch(logCombat({\n            origin: 'monster',\n            description: moveMsg\n          }), 1000);\n        }, 1000);\n        setTimeout(function () {\n          dispatch(updateMonster({\n            defense: newDefense\n          }));\n        }, 1100);\n      } else if (telegraphing.effect[m] == 'fatigue') {\n        const moveMsg = monster.name + \" used \" + telegraphing.name[m] + \", adding \" + telegraphing.power[m] + \" fatigue cards to the partys deck.\";\n        setTimeout(function () {\n          dispatch(logCombat({\n            origin: 'monster',\n            description: moveMsg\n          }), 1000);\n        }, 1000);\n\n        for (let each = 0; each < telegraphing.power[m]; each++) {\n          dispatch(addCardDiscard(afflictionCards.find(affliction => affliction.name === 'Fatigue')));\n        }\n      } else if (telegraphing.effect[m] == 'bleed') {\n        const moveMsg = monster.name + \" used \" + telegraphing.name[m] + \", adding \" + telegraphing.power[m] + \" bleed cards to the partys deck.\";\n        setTimeout(function () {\n          dispatch(logCombat({\n            origin: 'monster',\n            description: moveMsg\n          }), 1000);\n        }, 1000);\n        console.log('bleed move! :', afflictionCards.find(a => a.name === 'bleed'));\n\n        for (let each = 0; each < telegraphing.power[m]; each++) {\n          dispatch(addCardDiscard(afflictionCards.find(affliction => affliction.name === 'Bleed')));\n        }\n      } else if (telegraphing.effect[m] == 'stun') {\n        let heroList = ['mage', 'sword', 'shield'];\n        let target = getRandomRange(0, heroList.length);\n        let targetHero = heroList[target];\n        dispatch(addAilgments({\n          target: targetHero,\n          effect: 'stun',\n          duration: telegraphing.power[m]\n        }));\n        const moveMsg = monster.name + \" used \" + telegraphing.name[m] + \", stunning \" + targetHero + \" hero, for \" + telegraphing.power[m] + \" turns.\";\n        setTimeout(function () {\n          dispatch(logCombat({\n            origin: 'monster',\n            description: moveMsg\n          }), 1000);\n        }, 1000);\n      } else if (telegraphing.effect[m] == 'idle') {\n        state.monster.aligment.push('stun');\n        state.monster.aligmentDuration.push(telegraphing.power[m]);\n        const moveMsg = monster.name + \" used \" + telegraphing.name[m] + \", idling for \" + telegraphing.power[m] + \" turns.\";\n        setTimeout(function () {\n          dispatch(logCombat({\n            origin: 'monster',\n            description: moveMsg\n          }), 1000);\n        }, 1000);\n      } else if (telegraphing.effect[m] == 'heal') {\n        if (monster.health + telegraphing.power[m] > monster.total) {\n          monster.health = monster.total;\n        } else {\n          monster.health = monster.health + telegraphing.power[m];\n        }\n\n        const moveMsg = monster.name + \" used \" + telegraphing.name[m] + \", healing for \" + telegraphing.power[m] + \" health.\";\n        setTimeout(function () {\n          dispatch(logCombat({\n            origin: 'monster',\n            description: moveMsg\n          }), 1000);\n        }, 1000);\n      } else {//default\n      }\n    }\n\n    const moves = monster.moves;\n    const lengthOfMoves = Object.keys(moves).length;\n    let randomMove = getRandomRange(0, lengthOfMoves);\n    const newTelegraph = moves[randomMove];\n    setTimeout(function () {\n      dispatch(updateMonster({\n        telegraphing: newTelegraph\n      }));\n    }, 1200);\n  }\n\n  reduceAligments(state.player);\n  reduceMonsterAligments(monster);\n  setTimeout(function () {\n    dispatch(updatePlayer({\n      energy: 3,\n      defense: 0\n    }));\n  }, 1200);\n  setTimeout(function () {\n    dispatch(drawCard());\n  }, 1500);\n  setTimeout(function () {\n    dispatch(drawCard());\n  }, 2000);\n  setTimeout(function () {\n    dispatch(drawCard());\n  }, 2500);\n  setTimeout(function () {\n    dispatch(drawCard());\n  }, 3000);\n  setTimeout(function () {\n    dispatch(drawCard());\n    playerOverlay.style.height = \"0vh\";\n    playerOverlay.style.width = \"0vw\";\n  }, 3500);\n};","map":{"version":3,"sources":["/Users/uwu/Documents/Dev/weather-app/src/ducks/combat.js"],"names":["createAction","handleActions","useSelector","createSelector","updateMonster","updatePlayer","discardHand","drawCard","addCardDiscard","addAilgments","playCard","afflictionCards","updateCombat","logCombat","resetCombatLog","initialState","combatLog","origin","description","state","action","payload","selectCombat","combat","useCombat","strikeAnimation","bodyElement","transitionTime","animate","transform","duration","iterations","hitHero","roll","getRandomRange","damageFlash","document","getElementById","opacity","reduceAligments","player","index","offenseHeroAilgments","length","parseInt","offenseHeroAilgmentsDuration","splice","utilityHeroAilgments","utilityHeroAilgmentsDuration","defenseHeroAilgments","defenseHeroAilgmentsDuration","reduceMonsterAligments","monster","aligment","aligmentDuration","min","max","Math","floor","random","endTurn","dispatch","getState","playerOverlay","style","height","width","backgroundColor","position","zIndex","bottom","monsterBody","setTimeout","defense","telegraphing","console","log","includes","m","effect","dmg","power","moveMsg","name","trample","newDefense","newHealth","health","each","find","affliction","a","heroList","target","targetHero","push","total","moves","lengthOfMoves","Object","keys","randomMove","newTelegraph","energy"],"mappings":"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","sourcesContent":["import { createAction, handleActions } from \"redux-actions\";\nimport { useSelector } from \"react-redux\";\nimport { createSelector } from \"reselect\";\nimport { updateMonster } from './monster';\n\nimport { updatePlayer, discardHand, drawCard, addCardDiscard, addAilgments, playCard } from './player';\nimport {afflictionCards} from '../game-data/affliction-card-data';\n\nexport const updateCombat = createAction('combat/UPDATE_COMBAT');\nexport const logCombat = createAction('combat/LOG_COMBAT');\nexport const resetCombatLog = createAction('combat/RESET_COMBAT_LOG');\n\nconst initialState = {\n    combatLog : \n        [{\n            origin: 'player',\n            description: 'Start of combat'\n        }]\n};\n\nexport default handleActions({\n    [updateCombat]: (state, action) => ({ ...state, ...action.payload }),\n    [logCombat]: (state, action) => ({ ...state.combatLog, combatLog: [...state.combatLog, action.payload] })\n}, initialState);\n\n\n// how we grab data from the store\nconst selectCombat = createSelector(\n    state => state.combat,\n    combat => combat   \n)\n\nexport const useCombat = () => useSelector(selectCombat);\n\n\nfunction strikeAnimation(bodyElement){\n    let transitionTime = 500;\n    bodyElement.animate([\n        {transform: 'translate(0px,0px)'},\n        {transform: 'translate(-50px, 0px)'},\n        {transform: 'translate(-105px, 0px)'},\n        {transform: 'translate(1px, 0px)'},\n        {transform: 'translate(0, 0px)'}\n\n    ], {\n        duration: transitionTime,\n        iterations: 1\n    });\n}\n\nfunction hitHero(){\n    let roll = getRandomRange(0,3);\n\n    switch (roll) {\n        case 0:\n            damageFlash(document.getElementById('mageBody'))\n            break;\n        case 1:\n            damageFlash(document.getElementById('swordBody'))\n            break;\n        case 2:\n            damageFlash(document.getElementById('shieldBody'))\n            break;\n    }\n}\n\nfunction damageFlash(bodyElement){\n\n    let transitionTime = 500;\n    bodyElement.animate([\n        {opacity: 1},\n        {opacity: 0},\n        {opacity: .75},\n        {opacity: .5},\n        {opacity: 0},\n        {opacity: .75},\n        {opacity: 1}\n\n    ], {\n        duration: transitionTime,\n        iterations: 1\n    });\n    \n}\n\n\nfunction reduceAligments(player){\n\n    for (let index = 0; index < player.offenseHeroAilgments.length; index++) {\n        if ( parseInt(player.offenseHeroAilgmentsDuration[index]) - 1 > 0 ){\n            // last turn with given ailgment.\n            player.offenseHeroAilgmentsDuration[index] -= 1;\n\n        }else {\n            // aligment is removed.\n            player.offenseHeroAilgments.splice(index,1);\n            player.offenseHeroAilgmentsDuration.splice(index,1);\n        }\n    }\n\n    for (let index = 0; index < player.utilityHeroAilgments.length; index++) {\n        if ( parseInt(player.utilityHeroAilgmentsDuration[index]) - 1 > 0 ){\n            // last turn with given ailgment.\n            player.utilityHeroAilgmentsDuration[index] -= 1;\n\n        }else {\n            // aligment is removed.\n            player.utilityHeroAilgments.splice(index,1);\n            player.utilityHeroAilgmentsDuration.splice(index,1);\n        }\n    }\n\n    for (let index = 0; index < player.defenseHeroAilgments.length; index++) {\n        if ( parseInt(player.defenseHeroAilgmentsDuration[index]) - 1 > 0 ){\n            // last turn with given ailgment.\n            player.defenseHeroAilgmentsDuration[index] -= 1;\n\n        }else {\n            // aligment is removed.\n            player.defenseHeroAilgments.splice(index,1);\n            player.defenseHeroAilgmentsDuration.splice(index,1);\n        }\n    }\n}\n\nfunction reduceMonsterAligments(monster){\n    for (let index = 0; index < monster.aligment.length; index++) {\n        \n\n        if ( parseInt(monster.aligmentDuration[index]) - 1 === 1 ){\n            // last turn with given ailgment. Maybe...\n            monster.aligmentDuration[index] -= 1;\n\n        }else if ( parseInt(monster.aligmentDuration[index]) - 1 <= 0 ){\n            // aligment is removed.\n            monster.aligmentDuration.splice(index,1);\n            monster.aligment.splice(index,1);\n        }\n    }\n}\n\nfunction getRandomRange(min, max) {\n    return Math.floor(Math.random() * (max - min) + min);\n}\n\n\n\nexport const endTurn = () => (dispatch, getState) => {\n\n    let playerOverlay = document.getElementById('playerOverlay');\n\n    playerOverlay.style.height = \"50vh\"\n    playerOverlay.style.width = \"100vw\"\n    playerOverlay.style.transform = \"translate(0px,50px)\"\n    playerOverlay.style.backgroundColor = \"black\"\n    playerOverlay.style.opacity = .75\n    playerOverlay.style.position = \"absolute\"\n    playerOverlay.style.zIndex = 100\n    playerOverlay.style.bottom = 0\n\n    let monsterBody = document.getElementById('monsterOuterContainer');\n    \n    setTimeout( function(){ \n        dispatch( discardHand() )\n    }, 1000 );\n\n    const state = getState()\n    const player = state.player\n    const monster = state.monster\n\n    monster.defense = 0;\n\n    const telegraphing = monster.telegraphing\n\n    console.log('telegraph:', telegraphing)\n\n    if ( !monster.aligment.includes('stun') ){\n\n        for (let m = 0; m < telegraphing.effect.length; m++) {\n                \n            if ( telegraphing.effect[m] == \"damage\" ){\n\n                strikeAnimation(monsterBody);\n                hitHero();\n\n                const dmg = telegraphing.power[m]\n                const moveMsg = monster.name + \" used \" + telegraphing.name[m] + \", dealing\\n\" + telegraphing.power[m] + \" damage.\"\n\n                setTimeout( function(){\n                    dispatch(logCombat( {origin:'monster', description:moveMsg} ), 1000)\n                }, 1000);\n\n                const trample = player.defense - dmg\n                if ( trample <= 0 ){\n                    const newDefense = 0\n                    const newHealth = player.health + trample\n                    setTimeout( function(){ dispatch( updatePlayer({ health: newHealth, defense: newDefense }) ) },1000);\n                    \n                } else {\n                    const newDefense = trample\n                    setTimeout( function(){ dispatch( updatePlayer({ defense: newDefense }) ) },1000);    \n                }\n\n\n            } else if (telegraphing.effect[m] == 'defense') {\n\n\n                const newDefense = telegraphing.power[m]\n                const moveMsg = monster.name + \" used \" + telegraphing.name[m] + \", gained\\n +\" + telegraphing.power[m] + \" defense.\"\n\n                setTimeout( function(){\n                    //  combatMsgs.innerHTML = moveMsg \n                    dispatch(logCombat( {origin:'monster', description:moveMsg} ), 1000)\n                }, 1000)\n\n                setTimeout( function(){ \n                    dispatch( updateMonster({ defense: newDefense })) \n                },1100);\n            } else if (telegraphing.effect[m] == 'fatigue') {\n\n                const moveMsg = monster.name + \" used \" + telegraphing.name[m] + \", adding \" + telegraphing.power[m] + \" fatigue cards to the partys deck.\"\n\n                setTimeout( function(){\n                    dispatch(logCombat( {origin:'monster', description:moveMsg} ), 1000)\n                }, 1000);\n\n                for (let each = 0; each < telegraphing.power[m]; each++) {\n                    dispatch( addCardDiscard(afflictionCards.find( affliction => affliction.name === 'Fatigue')) )\n                }\n\n            } else if (telegraphing.effect[m] == 'bleed') {\n                const moveMsg = monster.name + \" used \" + telegraphing.name[m] + \", adding \" + telegraphing.power[m] + \" bleed cards to the partys deck.\"\n\n                setTimeout( function(){\n                    dispatch(logCombat( {origin:'monster', description:moveMsg} ), 1000)\n                }, 1000);\n\n                console.log('bleed move! :', afflictionCards.find( a => a.name ==='bleed'))\n\n                for (let each = 0; each < telegraphing.power[m]; each++) {\n                    dispatch( addCardDiscard(afflictionCards.find( affliction => affliction.name === 'Bleed')) )\n                }\n\n            }else if (telegraphing.effect[m] == 'stun') {\n\n                let heroList = ['mage', 'sword', 'shield']\n                let target = getRandomRange(0,heroList.length)\n                let targetHero = heroList[target]\n\n                dispatch( addAilgments({\n                        target : targetHero,\n                        effect :'stun',\n                        duration : telegraphing.power[m]\n                    })\n                )\n                const moveMsg = monster.name + \" used \" + telegraphing.name[m] + \", stunning \" + targetHero + \" hero, for \" + telegraphing.power[m] + \" turns.\"\n                setTimeout( function(){\n                    dispatch(logCombat( {origin:'monster', description:moveMsg} ), 1000)\n                }, 1000);\n\n            }else if (telegraphing.effect[m] == 'idle'){\n                state.monster.aligment.push('stun');\n                state.monster.aligmentDuration.push(telegraphing.power[m]);\n                const moveMsg = monster.name + \" used \" + telegraphing.name[m] + \", idling for \" + telegraphing.power[m] + \" turns.\"\n                setTimeout( function(){\n                    dispatch(logCombat( {origin:'monster', description:moveMsg} ), 1000)\n                }, 1000);\n            }else if (telegraphing.effect[m] == 'heal'){\n                if (monster.health + telegraphing.power[m] > monster.total){\n                    monster.health = monster.total;\n                }else{\n                    monster.health = monster.health + (telegraphing.power[m]);\n                }\n                const moveMsg = monster.name + \" used \" + telegraphing.name[m] + \", healing for \" + telegraphing.power[m] + \" health.\"\n                setTimeout( function(){\n                    dispatch(logCombat( {origin:'monster', description:moveMsg} ), 1000)\n                }, 1000);\n            }else{                \n                //default\n            }\n\n        }\n\n        const moves = monster.moves;\n        const lengthOfMoves = Object.keys(moves).length;\n        let randomMove = getRandomRange(0, lengthOfMoves);\n        const newTelegraph = moves[randomMove]\n        setTimeout( function(){ dispatch( updateMonster({ telegraphing: newTelegraph }) )}, 1200)\n    }\n\n    reduceAligments(state.player);\n    reduceMonsterAligments(monster);\n\n\n    setTimeout( function(){\n        dispatch( updatePlayer({ energy: 3, defense: 0 }) \n    )}, 1200);\n    \n    setTimeout( function(){     \n        dispatch( drawCard() )\n    }, 1500);\n\n    setTimeout( function(){\n        dispatch( drawCard() )\n    }, 2000);\n\n    setTimeout( function(){\n        dispatch( drawCard() )\n    }, 2500);\n\n    setTimeout( function(){\n        dispatch( drawCard() )\n    }, 3000);\n\n    setTimeout( function(){\n        dispatch( drawCard() )\n        playerOverlay.style.height = \"0vh\"\n        playerOverlay.style.width = \"0vw\"\n    }, 3500);\n\n\n}\n\n"]},"metadata":{},"sourceType":"module"}